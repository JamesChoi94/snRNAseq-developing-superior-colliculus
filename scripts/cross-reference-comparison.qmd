---
title: "Cross-reference comparison of superior colliculus cell-types"
author: "James Choi"
date: "Last compiled: `r Sys.Date()`"
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
    number-sections: true
    link-external-newwindow: true
    fig-align: center
editor: source
execute: 
  cache: true
  warning: false
  message: false
project:
  execute-dir: project
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = 'D:/MiamiProject/Park_snSeq_SuperiorColliculus/')
```

# Background

Several independent studies have attempted to classify and taxonomize neuron sub-types of the superior colliculus. We want to compare the subtypes identified in the current study to those from other studies. 

# Setup

```{r}
results_out <- 'results/cross-reference-comparison/'
dir.create(path = results_out)
```

```{r libraries}
library(R.matlab)
library(ComplexHeatmap)
library(scran)
library(SingleR)
library(Seurat)
# remotes::install_github("mojaveazure/seurat-disk")
library(SeuratDisk)
library(dplyr)
library(ggplot2)
library(patchwork)
library(reticulate)
library(tidyr)
# reticulate::py_install('Scrublet', pip = TRUE)
# reticulate::py_install('scanpy', pip = TRUE)
```

```{r}
# Plotting colors
neuron.cols <- c("#c2444c","#e14327","#be6231","#de8d26","#debc22","#b99f3e","#a6c336","#6f9a3e","#63d135","#59c251","#4db873","#36dbbc","#7b85dc","#6074eb","#554ea8","#6934c4","#9253ea","#542298","#ac69d3","#ce4ce2","#d980cc","#cc4bb5","#df35bd","#92337c","#d54681")
time.cols <- c("#dd4539","#d9b123","#68c545","#514fd1")
celltype.cols <- RColorBrewer::brewer.pal(n = 12, name = 'Paired')
celltype.cols[11] <- 'gold'

umap.axes <- ggplot(data.frame(x=10,y=10),aes(x=x,y,y)) +
  geom_point() +
  xlim(c(0,1)) + ylim(c(0,1)) +
  theme_classic() +
  xlab('UMAP 1') + ylab('UMAP 2') +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_text(size = 10),
        axis.line = element_line(
          color = 'black',
          arrow = arrow(angle = 15, length = unit(.35, 'cm'), type = 'closed')
        ),
        panel.background = element_rect(fill = 'transparent', color = NA),
        panel.border = element_rect(fill = 'transparent', color = NA)
  )
layout <- c(
  patchwork::area(t = 11, l = 1, b = 11, r = 1),
  patchwork::area(t = 1, l = 1, b = 11, r = 11)
)
```

```{r load-data}
sc <- readRDS(file = 'data/sc.rds')
neuron <- readRDS(file = 'data/neuron.rds')
names(neuron.cols) <- levels(neuron$subtype)
```


# Tsai 2022: Trans-seq

Study: [Tsai, N.Y., Wang, F., Toma, K. et al. Trans-Seq maps a selective mammalian retinotectal synapse instructed by Nephronectin. Nat Neurosci 25, 659--674 (2022). https://doi.org/10.1038/s41593-022-01068-8](https://doi.org/10.1038/s41593-022-01068-8)

From the Github README:

> Trans-Seq is a circuit mapping method that allows for transcriptomically profiling of postsynaptically connected neurons. Trans-Seq combines a fluorescent anterograde transsynaptic tracer, consisting of codon-optimized wheat germ agglutinin fused to mCherry, with single-cell RNA Sequencing. Connected neurons are recovered via FACS based on mCherry fluorescence. In our study, we used Trans-Seq to classify neuron types in the superior colliculus innervated by genetically-defined RGC types and predicted a neuronal pair from Î±RGCs to Nephronectin-positive wide-field neurons (NPWFs).

This snRNAseq dataset provides subtype annotations and DEGs for each cluster. The best direct comparison would be a joint cluster analysis with neurons from the present study and the Trans-seq study.


## Import and preprocess data

```{r, fig.height=3.5, fig.width=4}
load(file = 'ref/AllPanRGCClustered.RData')
allpan_slcgad$subtype <- Idents(allpan_slcgad)
allpan_slcgad$subtype <- factor(allpan_slcgad$subtype, levels = c('ESC1','ESC2','ESC3','ISC1','ISC2','ISC3','ISC4','ISC5'))
p.transseq <- umap.axes +
  (DimPlot(allpan_slcgad, group.by = 'subtype') + theme_void()) +
  plot_layout(design = layout)
p.transseq
```

Subtype information that is in the publication is not stored in the Seurat object `meta.data` but instead as the `Idents`.

```{r}
head(allpan_slcgad@meta.data)
```

```{r}
knitr::kable(x = table(allpan_slcgad$subtype))
```

```{r}
knitr::kable(x = table(allpan_slcgad$subtype, allpan_slcgad$batch))
```

## Check for batch effects

```{r}
#| fig.height: 4
#| fig.width: 4.5
DefaultAssay(allpan_slcgad) <- 'RNA'
allpan_slcgad <- allpan_slcgad %>% 
  NormalizeData() %>% 
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA() %>% 
  FindNeighbors(dims = 1:10) %>% 
  FindClusters() %>% 
  RunUMAP(dims = 1:10)
ElbowPlot(allpan_slcgad, ndims = 40)
p.batch <- umap.axes + (DimPlot(allpan_slcgad, group.by = 'orig.ident') + theme_void()) + plot_layout(design = layout)
p.batch
```

The figure shows significant batch effects between samples. Importantly, each sample has fewer than 200 cells, which is the default parameter value used in nearest-neighbor searches in the `FindIntegrationAnchors()` algorithm. See table below for cell counts by sample:

```{r}
table(allpan_slcgad$orig.ident)
```

```{r}
DefaultAssay(allpan_slcgad) <- 'RNA'
transseq <- SplitObject(allpan_slcgad, split.by = 'orig.ident')
transseq <- lapply(transseq, NormalizeData)
# transseq <- lapply(transseq, SCTransform)
transseq <- lapply(transseq, FindVariableFeatures)
transseq.feats <- SelectIntegrationFeatures(object.list = transseq)
# transseq <- PrepSCTIntegration(
#   object.list = transseq, 
#   anchor.features = transseq.feats
# )
transseq.anchors <- FindIntegrationAnchors(
  object.list = transseq,
  anchor.features = transseq.feats, 
  # normalization.method = 'SCT'
  )
transseq <- IntegrateData(
  anchorset = transseq.anchors,
  # normalization.method = 'SCT'
)
transseq <- transseq %>% 
  ScaleData() %>%
  RunPCA() %>% 
  FindNeighbors(dims = 1:10) %>% 
  FindClusters() %>% 
  RunUMAP(dims = 1:10)
p.batch <- umap.axes + (DimPlot(transseq, group.by = 'orig.ident') + theme_void()) + plot_layout(design = layout)
p.subtype <- umap.axes + (DimPlot(transseq, group.by = 'subtype', label = TRUE, label.size = 5) + theme_void()) + plot_layout(design = layout)
cowplot::plot_grid(p.batch, p.subtype)
```


## Recompute Trans-seq DEGs

```{r, eval=FALSE}
transseq.markers <- FindAllMarkers(
  object = allpan_slcgad,
  assay = 'RNA',
  slot = 'data',
  only.pos = TRUE
)
dt <- transseq.markers %>% 
  mutate(across(where(is.numeric), signif, 3)) %>% 
  filter(p_val_adj < 0.05) %>% 
  group_by(cluster) %>% 
  top_n(n = 3, wt = -p_val_adj) %>% 
  top_n(n = 3, wt = avg_log2FC)
knitr::kable(dt)
```


## SingleR: classify Trans-seq cells with neuron markers

```{r}
DefaultAssay(neuron) <- 'RNA'
DefaultAssay(allpan_slcgad) <- 'RNA'
transseq <- DietSeurat(allpan_slcgad, counts = TRUE, dimreducs = c('umap'))
transseq <- NormalizeData(transseq)
if (any(colnames(neuron) %in% colnames(transseq))) {
  print('duplicated cell barcodes in `neuron` and `transseq`')
}
transseq.sce <- SingleCellExperiment(
  assays = list(counts = transseq@assays$RNA@counts,
                logcounts = transseq@assays$RNA@data)
)
colData(transseq.sce) <- cbind(colData(transseq.sce), transseq@meta.data)
neuron.sce <- SingleCellExperiment(
  assays = list(counts = neuron@assays$RNA@counts,
                logcounts = neuron@assays$RNA@data)
)
colData(neuron.sce) <- cbind(colData(neuron.sce), neuron@meta.data)
```

```{r}
transseq.singler.results <- SingleR(
  test = transseq.sce, 
  ref = neuron.sce,
  labels = neuron$subtype,
  de.method = 'wilcox',
  aggr.ref = FALSE
)
write.csv(x = cbind(transseq@meta.data[c('subtype','orig.ident')], as.data.frame(transseq.singler.results)), file = paste0(results_out, 'SingleR_neuron-ref-transseq-query_SingleR-output.csv'))
```

### Results

```{r}
transseq.singler.results <- read.csv(file = paste0(results_out, 'SingleR_neuron-ref-transseq-query_SingleR-output.csv'), row.names = 1)
transseq$SingleR_sc.neuron <- plyr::mapvalues(
  x = rownames(transseq@meta.data),
  from = rownames(transseq.singler.results),
  to = transseq.singler.results$pruned.labels
)
transseq$SingleR_sc.neuron <- factor(x = transseq$SingleR_sc.neuron, levels = levels(neuron$subtype))
```

```{r}
# fig.height: 3
# fig.width: 7
p.singler.prop <- prop.table(table(transseq$SingleR_sc.neuron, transseq$subtype), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = levels(neuron$subtype)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none',
                     drop = FALSE) +
  labs(title = 'Predicted neuron sub-types in Trans-seq',
       subtitle = 'Rows sum to 100; Not all boxes labeled.') +
  ylab(label = 'Trans-seq published annotations\n(query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-transseq-query_percent-heatmap.tiff'), plot = p.singler.prop, device = 'tiff', height = 3.25, width = 7.25)
p.singler.prop
```

```{r}
# fig.height: 3
# fig.width: 7

# Allow rows/columns to be reordered by similarity
tmp <- prop.table(table(transseq$SingleR_sc.neuron, transseq$subtype), margin = 2)
tmp.x <- dendsort::dendsort(d = hclust(d = dist(tmp)))
tmp.x <- tmp.x$labels[tmp.x$order]
tmp.y <- dendsort::dendsort(d = hclust(d = dist(t(tmp))))
tmp.y <- tmp.y$labels[tmp.y$order]
p.singler.prop <- prop.table(table(transseq$SingleR_sc.neuron, transseq$subtype), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = rev(tmp.x)),
    Var2 = factor(Var2, levels = rev(tmp.y)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none',
                     drop = FALSE) +
  labs(title = 'Predicted neuron sub-types in Trans-seq',
       subtitle = 'Rows sum to 100; Not all boxes labeled.') +
  ylab(label = 'Trans-seq published annotations\n(query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-transseq-query_percent-heatmap-ordered.tiff'), plot = p.singler.prop, device = 'tiff', height = 3.25, width = 7.25)
p.singler.prop
```

```{r}
#| fig.height: 5
#| fig.width: 6
p.singler.umap <- DimPlot(transseq, group.by = 'SingleR_sc.neuron', pt.size = 3, shuffle = TRUE, label = TRUE, label.size = 4, repel = TRUE) +
  theme_void() +
  labs(title = 'Predicted neuron sub-types in Trans-seq') +
  scale_color_manual(values = neuron.cols,
                     drop = FALSE) +
  theme(legend.text = element_text(size = 12)) +
  guides(color = guide_legend(override.aes = list(size = 5))) 
p.singler.umap <- umap.axes + p.singler.umap + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-transseq-query_prediction-umap.tiff'), plot = p.singler.umap, device = 'tiff', height = 5, width = 6, dpi = 320)
p.singler.umap
```

```{r}
# table('subtype' = transseq.singler.results$pruned.labels) %>%
#   as.data.frame() %>%
#   mutate(subtype = factor(subtype, levels = levels(neuron$subtype))) %>%
#   ggplot(aes(x = '', y = Freq, fill = subtype)) +
#   geom_bar(aes(fill = subtype), color = 'black', stat = 'identity') +
#   coord_polar(theta = 'y', start = 0) +
#   theme_bw() + 
#   theme(legend.position = 'none')
#   scale_y_continuous()
names(neuron.cols) = levels(neuron$subtype)
predictCounts = sort(table(transseq.singler.results$pruned.labels))
{
  tiff(filename = paste0(results_out, 'SingleR_neuron-ref-transseq-query_prediction-pie.tiff'), width = 6, height = 6, units = 'in', res = 320)
  pie(x = predictCounts, 
      labels = names(predictCounts),
      col = neuron.cols[names(predictCounts)],
      main = "Predicted neuron subtypes in Trans-seq",
      radius = 1,
      cex = 1.6,
      cex.main = 1.2,
      cex.main = 1.2)
  dev.off()
}
```


## SingleR: Classify SC neurons with Trans-seq markers

```{r}
DefaultAssay(neuron) <- 'RNA'
DefaultAssay(allpan_slcgad) <- 'RNA'
transseq <- DietSeurat(allpan_slcgad, counts = TRUE, dimreducs = c('umap'))
transseq <- NormalizeData(transseq)
if (any(colnames(neuron) %in% colnames(transseq))) {
  print('duplicated cell barcodes in `neuron` and `transseq`')
}
transseq.sce <- SingleCellExperiment(
  assays = list(counts = transseq@assays$RNA@counts,
                logcounts = transseq@assays$RNA@data)
)
colData(transseq.sce) <- cbind(colData(transseq.sce), transseq@meta.data)
neuron.sce <- SingleCellExperiment(
  assays = list(counts = neuron@assays$RNA@counts,
                logcounts = neuron@assays$RNA@data)
)
colData(neuron.sce) <- cbind(colData(neuron.sce), neuron@meta.data)
```

```{r}
sc.transseq.singler.results <- SingleR(
  test = neuron.sce, 
  ref = transseq.sce,
  labels = transseq.sce$subtype,
  de.method = 'wilcox',
  aggr.ref = FALSE,
  BPPARAM = BiocParallel::SnowParam(workers = 1)
)
write.csv(x = cbind(neuron@meta.data[c('subtype','orig.ident')], as.data.frame(sc.transseq.singler.results)), file = paste0(results_out, 'SingleR_transseq-ref-neuron-query_SingleR-output.csv'))
```

### Results

```{r}
sc.transseq.singler.results <- read.csv(file = paste0(results_out, 'SingleR_transseq-ref-neuron-query_SingleR-output.csv'), row.names = 1)
neuron$SingleR_Transseq <- plyr::mapvalues(
  x = rownames(neuron@meta.data),
  from = rownames(sc.transseq.singler.results),
  to = sc.transseq.singler.results$pruned.labels
)
neuron$SingleR_Transseq <- factor(neuron$SingleR_Transseq, levels = levels(transseq$subtype))
```

Percent prediction heatmap

```{r}
#| fig.height: 6.5
#| fig.width: 4.25
p.singler.prop <- prop.table(table(neuron$SingleR_Transseq, neuron$subtype), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = levels(transseq$subtype)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = 'Predicted Trans-seq sub-types in SC (current study)',
       subtitle = 'Rows sum to 100; Not all boxes labeled.') +
  ylab(label = 'Neuron sub-types in current study\n(query data)') + 
  xlab(label = 'Trans-seq published annotations\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_transseq-ref-neuron-query_percent-heatmap.tiff'), plot = p.singler.prop, device = 'tiff', height = 6.5, width = 4.25)
p.singler.prop
```

```{r}
#| fig.height: 6.5
#| fig.width: 4.25

# Allow rows/columns to be reordered by similarity
tmp <- prop.table(table(neuron$SingleR_Transseq, neuron$subtype), margin = 2)
tmp.x <- dendsort::dendsort(d = hclust(d = dist(tmp)))
tmp.x <- tmp.x$labels[tmp.x$order]
tmp.y <- dendsort::dendsort(d = hclust(d = dist(t(tmp))))
tmp.y <- tmp.y$labels[tmp.y$order]
p.singler.prop <- prop.table(table(neuron$SingleR_Transseq, neuron$subtype), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = rev(tmp.x)),
    Var2 = factor(Var2, levels = tmp.y),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = stringr::str_wrap('Predicted Trans-seq sub-types in SC (current study)', width = 40),
       subtitle = 'Rows sum to 100; Not all boxes labeled.') +
  ylab(label = 'Neuron sub-types in current study\n(query data)') + 
  xlab(label = 'Trans-seq published annotations\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_transseq-ref-neuron-query_percent-heatmap-ordered.tiff'), plot = p.singler.prop, device = 'tiff', height = 6.5, width = 4.25)
p.singler.prop
```


Prediction UMAP

```{r}
#| fig.height: 5
#| fig.width: 6
p.singler.umap <- DimPlot(neuron, group.by = 'SingleR_Transseq', pt.size = 1.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Predicted Trans-seq sub-types in SC (current study)') +
  # scale_color_manual(values = neuron.cols) +
  theme(legend.text = element_text(size = 12)) +
  guides(color = guide_legend(override.aes = list(size = 5))) 
p.singler.umap <- umap.axes + p.singler.umap + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'SingleR_transseq-ref-neuron-query_prediction-umap.tiff'), plot = p.singler.umap, device = 'tiff', height = 5, width = 6, dpi = 320)
p.singler.umap
```


Stacked bargraph

```{r}
#| fig.height: 3
#| fig.width: 4
p.time <- table(neuron$SingleR_Transseq, neuron$time) %>% 
  as.data.frame() %>% 
  ggplot(mapping = aes(x = Var2, y = Freq)) + 
  geom_bar(mapping = aes(fill = Var1), position = 'stack', stat = 'identity',
           color = 'black') +
  scale_fill_discrete(name = 'Predicted\nTrans-seq\nclass') +
  ylab(label = 'Cell count') + 
  xlab(label = 'Current study time-point') + 
  theme_bw()
ggsave(filename = paste0(results_out, 'SingleR_transseq-ref-neuron-query_prediction-time-barplot.tiff'), plot = p.time, device = 'tiff', height = 3, width = 4, dpi = 320)
p.time
```


## Integrated neuron analysis

```{r}
merged <- merge(neuron, transseq)
table(merged$orig.ident)
not.shared1 <- setdiff(rownames(neuron), rownames(transseq))
not.shared2 <- setdiff(rownames(transseq), rownames(neuron))
not.shared <- union(not.shared1, not.shared2); rm(not.shared1, not.shared2)
shared <- intersect(rownames(neuron), rownames(transseq))
```


* *Gfap* is in `not.shared`: `r 'Gfap' %in% not.shared`
* *Cxcr1* is in `not.shared`: `r 'Cxcr1' %in% not.shared`


```{r}
FetchData(merged, c('Gfap','Slc17a6','orig.ident')) %>% 
  group_by(orig.ident) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(neuron, c('Gfap','Slc17a6','orig.ident')) %>% 
  group_by(orig.ident) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(transseq, c('Gfap','Slc17a6','orig.ident')) %>% 
  group_by(orig.ident) %>% 
  summarise(across(where(is.numeric), mean))
```

```{r}
FetchData(merged, c('Gfap','Cxcr1','orig.ident')) %>% 
  group_by(orig.ident) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(neuron, c('Gfap','Cxcr1','orig.ident')) %>% 
  group_by(orig.ident) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(transseq, c('Gfap','Cxcr1','orig.ident')) %>% 
  group_by(orig.ident) %>% 
  summarise(across(where(is.numeric), mean))
```


Based on these outputs, running `merge` on the two `Seurat` objects yields another `Seurat` object whereby features that were not present in both datasets, e.g. *Cxcr1.*, are filled with zero counts.


```{r}
tmp <- merged
merged@meta.data %>% 
  group_by(orig.ident) %>% 
  summarise(meanFeature = mean(nFeature_RNA))
merged <- SplitObject(merged, split.by = 'orig.ident')
merged <- lapply(merged, NormalizeData)

merged_sce <- SingleCellExperiment(
  assays = list(counts = tmp@assays$RNA@counts,
                logcounts = tmp@assays$RNA@data)
)
colData(merged_sce) <- cbind(colData(merged_sce), tmp@meta.data)
gene.stats <- scran::modelGeneVar(x = merged_sce, block = merged_sce$orig.ident)
merged.feats <- getTopHVGs(stats = gene.stats, fdr.threshold = 0.05)
anchor.feats <- merged.feats[merged.feats %in% shared]
anchors <- FindIntegrationAnchors(object.list = merged, anchor.features = anchor.feats, normalization.method = 'LogNormalize')
merged <- IntegrateData(anchorset = anchors, features = anchor.feats, normalization.method = 'LogNormalize')
DefaultAssay(merged) <- 'integrated'
merged <- merged %>% 
  ScaleData() %>% 
  RunPCA()
ElbowPlot(merged, ndims = 40)
merged <- merged %>% 
  FindNeighbors(dims = 1:15) %>% 
  RunUMAP(dims = 1:15)
```


### Results

```{r}
#| fig.height: 5
#| fig.width: 6
p.transseq <- DimPlot(
  object = merged, 
  group.by = 'orig.ident',
  shuffle = TRUE,
  pt.size = 1
  ) + 
  theme_void() + 
  labs(title = 'Cells colored by sample') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.transseq <- umap.axes + p.transseq + plot_layout(design = layout)
p.transseq
ggsave(filename = paste0(results_out, 'transseq-integrated-umap.tiff'), plot = p.transseq, device = 'tiff', height = 5, width = 6, dpi = 320)
```


```{r}
#| fig.height: 5
#| fig.width: 6
merged$study <- ifelse(
  test = merged$orig.ident %in% c('E19', 'P4', 'P8', 'P21'),
  yes = 'Current',
  no = 'Trans-seq'
)
p.study <- DimPlot(merged, group.by = 'study', shuffle = TRUE, pt.size = 1) +
  theme_void() +
  labs(title = 'Cells colored by study') +
  theme(legend.text = element_text(size = 10)) +
  scale_color_manual(values = c('Current' = 'black', 'Trans-seq' = 'red')) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.study <- umap.axes + p.study + plot_layout(design = layout)
p.study
ggsave(filename = paste0(results_out, 'transseq-integrated-umap-study.tiff'), plot = p.study, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

```{r}
#| fig.height: 5
#| fig.width: 6
p.subtype <- DimPlot(merged, group.by = 'subtype', shuffle = TRUE, pt.size = 1) +
  theme_void() +
  labs(title = 'Cells colored by subtype') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.subtype <- umap.axes + p.subtype + plot_layout(design = layout)
p.subtype
ggsave(filename = paste0(results_out, 'transseq-integrated-umap-subtype.tiff'), plot = p.subtype, device = 'tiff', height = 5, width = 6, dpi = 320)
```

```{r}
g <- 'Pitx2'
p <- FeaturePlot(merged, feature = g, order = TRUE, pt.size = 1) +
  theme_void() +
  labs(title = g) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.subtype <- umap.axes + p.subtype + plot_layout(design = layout)
```



# Cheung et al. 2021: Vector-seq

Study: [Cheung V, Chung P, Bjorni M, Shvareva VA, Lopez YC, Feinberg EH. Virally encoded connectivity transgenic overlay RNA sequencing (VECTORseq) defines projection neurons involved in sensorimotor integration. Cell Rep. 2021 Dec 21;37(12):110131. doi: 10.1016/j.celrep.2021.110131. PMID: 34936877; PMCID: PMC8719358.](https://doi.org/10.1016/j.celrep.2021.110131)

*STAR:In brief*:

> Neurons with different axonal projection targets and distinct molecular and functional properties are intermingled throughout the brain. Cheung et al. establish a high-throughput method, VECTORseq, to transcriptionally define projection neurons. The method reimagines transgenes expressed by widely used retrogradely infecting viruses as multiplexed RNA barcodes that are detected in single-cell sequencing.

From graphical abstract:
> 1. Inject retrograde viruses in projection targets, dissect & sequence source structure.
> 2. 

This snRNAseq dataset is provided as both `raw_feature_bc_matrix.h5` and `filtered_feature_bc_matrix.h5` from [GEO with accession GSE189907](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM5709413). The files needed to be downloaded and processed. We can extract Cheung's cell-type classification results from the processed `.h5` files.

## Import and preprocess data

```{r}
dir.create(path = 'ref/Cheung-et-al-2021/')
# download.file(url = 'https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSM5709413&format=file&file=GSM5709413%5Fsc%5Fadata%2Eh5ad%2Egz', destfile = 'ref/Cheung-et-al-2021/sc_adata.h5ad.gz', timeout = 600)
# R.utils::gunzip('ref/Cheung-et-al-2021/sc_adata.h5ad.gz')
# unzip(zipfile = 'ref/Cheung-et-al-2021/all.zip')
# 
# # For all SC celltypes as shown in Figure 3B
# SeuratDisk::Convert(
#   source = 'ref/Cheung-et-al-2021/processed/processed/all/adata.h5ad', 
#   dest = 'ref/Cheung-et-al-2021/processed/processed/all/adata.h5seurat',
#   overwrite = FALSE
# )
# # For excitatory neurons only (so we can re-use UMAP coords from original paper as shown in Figure 3C)
# SeuratDisk::Convert(
#   source = 'ref/Cheung-et-al-2021/processed/processed/excitatory/adata.h5ad',
#   dest = 'ref/Cheung-et-al-2021/processed/processed/excitatory/adata.h5seurat',
#   overwrite = FALSE
# )
```

```{r}
cheung <- LoadH5Seurat(file = 'ref/Cheung-et-al-2021/processed/processed/all/adata.h5seurat')
# Wrangle metadata to match column names as `neuron`
cheung$orig.ident <- cheung$sample_number
# python logical values are 0 or 1, but needs to be adjusted since R is 1-indexed and python is 0-indexed
cheung@meta.data$AAVRG.CAG.TDTOMATO <- cheung@meta.data$AAVRG.CAG.TDTOMATO-1
cheung@meta.data$AAVRG.CAG.GFP <- cheung@meta.data$AAVRG.CAG.GFP-1
cheung@meta.data$HSV.CRE <- cheung@meta.data$HSV.CRE-1
cheung@meta.data$transgene_present <- cheung@meta.data$transgene_present-1
```

Neuron subtypes presented in original publication had up to 35 clusters. Excitatory and inhibitory subtypes were manually annotated. However, the exact cluster identities for excitatory or inhibitory neurons were not provided in the [Vectorseq analysis script](https://github.com/vic-cheung/vectorseq/blob/main/scripts/3454/sc/pipeline_run/excitatory_analysis.py) (see lines 14-28). The authors used different clustering parameters than compared to those provided in the `anndata` object. We therefore use a combination of marker expression clustering to identify the two neuronal classes.

The following two code chunk extracts the cell barcodes for those from excitatory and inhibitory neuron subsets. This is a one-time operation.

Addendum 2023-01-25: Simply convert the processed excitatory `adata.h5ad` file for the excitatory neuron dataset used to generate Figure 3C from the original publication. 

```{python, eval=FALSE}
# import pandas as pd
# import numpy as np
# import scanpy as sc
# cheungExcitatory = sc.read_h5ad('ref/Cheung-et-al-2021/processed/processed/excitatory/adata.h5ad')
# cheungExcitatoryNames = cheungExcitatory.obs
# cheungInhibitory = sc.read_h5ad('ref/Cheung-et-al-2021/processed/processed/inhibitory/adata.h5ad')
# cheungInhibitoryNames = cheungInhibitory.obs
# del cheungExcitatory
# del cheungInhibitory
# quit
```

```{r, eval=FALSE}
# cheungExcitatory <- py$cheungExcitatoryNames
# cheungInhibitory <- py$cheungInhibitoryNames
# cheungNeurons <- c(rep('Ex.Neuron', nrow(cheungExcitatory)),
#                    rep('Inh.Neuron', nrow(cheungInhibitory)))
# names(cheungNeurons) <- c(cheungExcitatory, cheungInhibitory)
# notShared = colnames(cheungExcitatory)[which(!colnames(cheungExcitatory) %in% colnames(cheungInhibitory))]
# cheungInhibitory[notShared] = NA
# cheungNeuronsMetadata = rbind(cheungExcitatory, cheungInhibitory)
# cheungNeuronsMetadata$Class = cheungNeurons
# write.csv(x = cheungNeuronsMetadata, file = paste0(results_out, 'Cheung-et-al-2021_neuron-metadata.csv'))
```

Note: in code chunk below, when `cheungNeurons` is imported, `cheungNeurons$merged_remapped_leid_0.6` contains the exxcitatory neuron cluster information that is presented in Figure 3C and 3E of the Cheung et al. paper.

```{r}
#| fig.width: 20
#| fig.height: 5.5
cheungNeurons <- read.csv(file = paste0(results_out, 'Cheung-et-al-2021_neuron-metadata.csv'), row.names = 1)
Idents(cheung) <- 'leiden_0.6'
cheung.dotplot <- DotPlot(cheung, features = c('Ly6g', 'Mmp9', 'Ccr2', 'Ly6c2', 'Spi1', 'Gpnmb', 'P2ry12', 'Tmem119', 'Hexb', 'Mki67', 'Col1a1', 'Col1a2', 'Postn', 'Cldn5', 'Podxl', 'Pecam1', 'Acta2', 'Cspg4', 'Pdgfrb', 'Pdgfra', 'Tnr', 'Kcnj8','Bmp4', 'Mbp', 'Mog', 'Sox9', 'Sox10', 'Ascl1', 'Dcx', 'Slc1a2', 'Aqp4', 'Gfap', 'Atp1a2', 'Foxj1', 'Cfap126', 'Slc17a6', 'Thy1', 'Gad1', 'Gad2', 'Ttr'), assay = 'RNA', group.by = 'leiden_0.6') +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1))
cheung$celltype <- plyr::mapvalues(
  x = rownames(cheung@meta.data),
  from = rownames(cheungNeurons),
  to = cheungNeurons$Class
)
cheung$celltype = ifelse(
  test = cheung$celltype %in% c("Ex.Neuron", "Inh.Neuron"),
  yes = cheung$celltype,
  no = 'other'
)
# Save identities
write.csv(x = cheung@meta.data, file = paste0(results_out, 'Cheung-et-al-2021_metadata.csv'))
# Figure summary
cheung.leiden.dimplot <- umap.axes + (DimPlot(cheung, group.by = 'leiden_0.6', label = TRUE, label.size = 5) + theme_void()) + plot_layout(design = layout)
cheung.celltype.dimplot <- umap.axes + (DimPlot(cheung, group.by = 'celltype', label = TRUE, label.size = 5) + theme_void()) + plot_layout(design = layout)
cheung.summary <- cowplot::plot_grid(cheung.leiden.dimplot, cheung.celltype.dimplot, cheung.dotplot, rel_widths = c(1,1,1.5), ncol = 3)
ggsave(filename = paste0(results_out, 'Cheung-et-al-2021_summary.tiff'), plot = cheung.summary, device = 'tiff', height = 5.5, width = 20)
cheung.summary
```


## SingleR: classify Vector-seq cells with neuron markers

```{r}
DefaultAssay(neuron) <- 'RNA'
vectorseq <- DietSeurat(cheung, counts = TRUE, dimreducs = c('umap'))
vectorseq <- NormalizeData(vectorseq)
if (any(colnames(neuron) %in% colnames(vectorseq))) {
  print('duplicated cell barcodes in `neuron` and `transseq`')
}
vectorseq.sce <- SingleCellExperiment(
  assays = list(counts = vectorseq@assays$RNA@counts,
                logcounts = vectorseq@assays$RNA@data)
)
colData(vectorseq.sce) <- cbind(colData(vectorseq.sce), vectorseq@meta.data)
neuron.sce <- SingleCellExperiment(
  assays = list(counts = neuron@assays$RNA@counts,
                logcounts = neuron@assays$RNA@data)
)
colData(neuron.sce) <- cbind(colData(neuron.sce), neuron@meta.data)
```

```{r}
vectorseq.singler.results <- SingleR(
  test = vectorseq.sce, 
  ref = neuron.sce,
  labels = as.character(neuron$subtype),
  de.method = 'wilcox',
  aggr.ref = FALSE
)
write.csv(x = cbind(vectorseq@meta.data[c('leiden_0.6', 'barcode')], as.data.frame(vectorseq.singler.results)), file = paste0(results_out, 'SingleR_neuron-ref-vectorseq-query_SingleR-output.csv'))
```


### Results

```{r}
vectorseq.singler.results <- read.csv(file = paste0(results_out, 'SingleR_neuron-ref-vectorseq-query_SingleR-output.csv'), row.names = 1)
vectorseq$SingleR_sc.neuron <- plyr::mapvalues(
  x = rownames(vectorseq@meta.data),
  from = rownames(vectorseq.singler.results),
  to = vectorseq.singler.results$pruned.labels
)
vectorseq$SingleR_sc.neuron <- factor(x = vectorseq$SingleR_sc.neuron, levels = levels(neuron$subtype))
```


```{r}
#| fig.height: 8
#| fig.width: 7
p.singler.prop <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$leiden_0.6), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = levels(neuron$subtype)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = 'Predicted neuron sub-types in Vector-seq') +
  ylab(label = 'Vector-seq published annotations\n(query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-vectorseq-query_percent-heatmap.tiff'), plot = p.singler.prop, device = 'tiff', height = 8, width = 7)
p.singler.prop
```

```{r}
#| fig.height: 8
#| fig.width: 7

# Allow rows/columns to be reordered by similarity
tmp <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$leiden_0.6), margin = 2)
tmp.x <- dendsort::dendsort(d = hclust(d = dist(tmp)))
tmp.x <- tmp.x$labels[tmp.x$order]
tmp.y <- dendsort::dendsort(d = hclust(d = dist(t(tmp))))
tmp.y <- tmp.y$labels[tmp.y$order]
p.singler.prop <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$leiden_0.6), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = rev(tmp.x)),
    Var2 = factor(Var2, levels = rev(tmp.y)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = 'Predicted neuron sub-types in Vector-seq') +
  ylab(label = 'Vector-seq published annotations\n(query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-vectorseq-query_percent-heatmap-ordered.tiff'), plot = p.singler.prop, device = 'tiff', height = 8, width = 7)
p.singler.prop
```

```{r}
#| fig.height: 5
#| fig.width: 6
p.singler.umap <- DimPlot(vectorseq, group.by = 'SingleR_sc.neuron', pt.size = 0.5, shuffle = TRUE, label = TRUE, label.size = 3.5) +
  theme_void() +
  labs(title = 'Predicted neuron sub-types in Vector-seq') +
  scale_color_manual(values = neuron.cols) +
  theme(legend.text = element_text(size = 12)) +
  guides(color = guide_legend(override.aes = list(size = 5))) 
p.singler.umap <- umap.axes + p.singler.umap + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-vectorseq-query_prediction-umap.tiff'), plot = p.singler.umap, device = 'tiff', height = 5, width = 6, dpi = 320)
p.singler.umap
```



## SingleR: classify Vector-seq excitatory neurons with neuron markers

```{r}
cheungEx <- LoadH5Seurat(file = 'ref/Cheung-et-al-2021/processed/processed/excitatory/adata.h5seurat', assays = 'RNA')
Idents(cheungEx) = 'merged_remapped_leid_0.6'
# python logical values are 0 or 1, but needs to be adjusted since R is 1-indexed and python is 0-indexed
cheungEx@meta.data$AAVRG.CAG.TDTOMATO <- cheungEx@meta.data$AAVRG.CAG.TDTOMATO-1
cheungEx@meta.data$AAVRG.CAG.GFP <- cheungEx@meta.data$AAVRG.CAG.GFP-1
cheungEx@meta.data$HSV.CRE <- cheungEx@meta.data$HSV.CRE-1
cheungEx@meta.data$transgene_present <- cheungEx@meta.data$transgene_present-1
```

```{r}
DefaultAssay(neuron) <- 'RNA'
vectorseq <- DietSeurat(cheungEx, counts = TRUE, dimreducs = c('umap'))
vectorseq <- NormalizeData(vectorseq)
if (any(colnames(neuron) %in% colnames(vectorseq))) {
  print('duplicated cell barcodes in `neuron` and `transseq`')
}
vectorseq.sce <- SingleCellExperiment(
  assays = list(counts = vectorseq@assays$RNA@counts,
                logcounts = vectorseq@assays$RNA@data)
)
colData(vectorseq.sce) <- cbind(colData(vectorseq.sce), vectorseq@meta.data)
neuron.sce <- SingleCellExperiment(
  assays = list(counts = neuron@assays$RNA@counts,
                logcounts = neuron@assays$RNA@data)
)
colData(neuron.sce) <- cbind(colData(neuron.sce), neuron@meta.data)
```

```{r}
vectorseq.singler.results <- SingleR(
  test = vectorseq.sce, 
  ref = neuron.sce,
  labels = as.character(neuron$subtype),
  de.method = 'wilcox',
  aggr.ref = FALSE
)
write.csv(x = cbind(vectorseq@meta.data[c('merged_remapped_leid_0.6', 'barcode')], as.data.frame(vectorseq.singler.results)), file = paste0(results_out, 'SingleR_neuron-ref-vectorseq-excitatory-query_SingleR-output.csv'))
```

### Results

```{r}
vectorseq.singler.results <- read.csv(file = paste0(results_out, 'SingleR_neuron-ref-vectorseq-excitatory-query_SingleR-output.csv'), row.names = 1)
vectorseq$SingleR_sc.neuron <- plyr::mapvalues(
  x = rownames(vectorseq@meta.data),
  from = rownames(vectorseq.singler.results),
  to = vectorseq.singler.results$pruned.labels
)
vectorseq$SingleR_sc.neuron <- factor(x = vectorseq$SingleR_sc.neuron, levels = levels(neuron$subtype))
```


```{r}
#| fig.height: 8
#| fig.width: 7
p.singler.prop <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$merged_remapped_leid_0.6), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = levels(neuron$subtype)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = 'Predicted neuron sub-types in Vector-seq') +
  ylab(label = 'Vector-seq Excitatory Neuron published annotations\n(query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-vectorseq-excitatory-query_percent-heatmap.tiff'), plot = p.singler.prop, device = 'tiff', height = 8, width = 7)
p.singler.prop
```

```{r}
#| fig.height: 8
#| fig.width: 7

# Allow rows/columns to be reordered by similarity
tmp <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$merged_remapped_leid_0.6), margin = 2)
tmp.x <- dendsort::dendsort(d = hclust(d = dist(tmp)), type = 'average')
tmp.x <- tmp.x$labels[tmp.x$order]
tmp.y <- dendsort::dendsort(d = hclust(d = dist(t(tmp))), type = 'average')
tmp.y <- tmp.y$labels[tmp.y$order]
p.singler.prop <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$merged_remapped_leid_0.6), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = rev(tmp.x)),
    Var2 = factor(Var2, levels = rev(tmp.y)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent >= 5, yes = Percent, no = NA),
    label.color = ifelse(test = Percent >= 70, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = 'Predicted neuron sub-types in Vector-seq',
       subtitle = 'Excitatory neuron clusters (see Cheung et al. Figure 3C)') +
  ylab(label = 'Vector-seq excitatory neuron\npublished annotations (query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-vectorseq-excitatory-query_percent-heatmap-ordered.tiff'), plot = p.singler.prop, device = 'tiff', height = 6, width = 7)
p.singler.prop
```

```{r}
#| fig.height: 5
#| fig.width: 6
p.singler.umap <- DimPlot(vectorseq, group.by = 'SingleR_sc.neuron', pt.size = 0.5, shuffle = TRUE, label = TRUE, label.size = 3.5) +
  theme_void() +
  labs(title = 'Predicted neuron sub-types in Vector-seq\nexcitatory neurons') +
  scale_color_manual(values = neuron.cols) +
  theme(legend.text = element_text(size = 12)) +
  guides(color = guide_legend(override.aes = list(size = 5))) 
p.singler.umap <- umap.axes + p.singler.umap + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-vectorseq-excitatory-query_prediction-umap.tiff'), plot = p.singler.umap, device = 'tiff', height = 5, width = 6, dpi = 320)
p.singler.umap
```

```{r}
p.singler.umap2 <- DimPlot(vectorseq, group.by = 'merged_remapped_leid_0.6', pt.size = 0.5, shuffle = TRUE, label = TRUE, label.size = 3.5) +
  theme_void() +
  labs(title = 'Original excitatory neuron annotation',
       subtitle = 'Cheung et al. Vector-seq (Figure 3C)') +
  # scale_color_manual(values = neuron.cols) +
  theme(legend.text = element_text(size = 12)) +
  guides(color = guide_legend(override.aes = list(size = 5))) 
p.singler.umap2 <- umap.axes + p.singler.umap2 + plot_layout(design = layout)
p.singler.combined = cowplot::plot_grid(p.singler.umap, p.singler.umap2, ncol = 2)
ggsave(filename = paste0(results_out, 'SingleR_neuron-ref-vectorseq-excitatory-query_prediction-umap-with-original.tiff'), plot = p.singler.combined, device = 'tiff', height = 5, width = 11.5, dpi = 320)
```

## SingleR: classify SC neurons with Vector-seq markers

```{r}
DefaultAssay(neuron) <- 'RNA'
vectorseq <- DietSeurat(cheung, counts = TRUE, dimreducs = c('umap'))
vectorseq <- NormalizeData(vectorseq)
if (any(colnames(neuron) %in% colnames(vectorseq))) {
  print('duplicated cell barcodes in `neuron` and `vectorseq`')
}
vectorseq.sce <- SingleCellExperiment(
  assays = list(counts = vectorseq@assays$RNA@counts,
                logcounts = vectorseq@assays$RNA@data)
)
colData(vectorseq.sce) <- cbind(colData(vectorseq.sce), vectorseq@meta.data)
neuron.sce <- SingleCellExperiment(
  assays = list(counts = neuron@assays$RNA@counts,
                logcounts = neuron@assays$RNA@data)
)
colData(neuron.sce) <- cbind(colData(neuron.sce), neuron@meta.data)
```

```{r}
# !!!!!!!!!!!!!
sc.vectorseq.singler.results <- SingleR(
  test = neuron.sce, 
  ref = vectorseq.sce,
  labels = vectorseq.sce$leiden_0.6,
  aggr.ref = TRUE,
  BPPARAM = BiocParallel::SnowParam(workers = 1) # Remember multiworker = duplicating objects!! This is memory-intensive with multiple worker
)
write.csv(x = cbind(neuron@meta.data[c('subtype','orig.ident')], as.data.frame(sc.vectorseq.singler.results)), file = paste0(results_out, 'SingleR_vectorseq-ref-neuron-query_SingleR-output.csv'))
```

### Results

```{r}
sc.vectorseq.singler.results <- read.csv(file = paste0(results_out, 'SingleR_vectorseq-ref-neuron-query_SingleR-output.csv'), row.names = 1)
neuron$SingleR_Vectorseq <- plyr::mapvalues(
  x = rownames(neuron@meta.data),
  from = rownames(sc.vectorseq.singler.results),
  to = sc.vectorseq.singler.results$pruned.labels
)
neuron$SingleR_Vectorseq <- factor(neuron$SingleR_Vectorseq, levels = 0:max(as.numeric(as.character(neuron$SingleR_Vectorseq)), na.rm = TRUE))
```

Percent prediction heatmap

```{r}
#| fig.height: 6
#| fig.width: 8
p.singler.prop <- prop.table(table(neuron$SingleR_Vectorseq, neuron$subtype), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = levels(vectorseq$leiden_0.6)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = 'Predicted Vector-seq sub-types in SC (current study)',
       subtitle = 'Rows sum to 100; Not all boxes labeled.') +
  ylab(label = 'Neuron sub-types in current study\n(query data)') + 
  xlab(label = 'Vector-seq published annotations\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_vectorseq-ref-neuron-query_percent-heatmap.tiff'), plot = p.singler.prop, device = 'tiff', height = 6, width = 8)
p.singler.prop
```

```{r}
#| fig.height: 6
#| fig.width: 8
# Allow rows/columns to be reordered by similarity
tmp <- prop.table(table(neuron$SingleR_Vectorseq, neuron$subtype), margin = 2)
tmp.x <- dendsort::dendsort(d = hclust(d = dist(tmp)))
tmp.x <- tmp.x$labels[tmp.x$order]
tmp.y <- dendsort::dendsort(d = hclust(d = dist(t(tmp))))
tmp.y <- tmp.y$labels[tmp.y$order]
p.singler.prop <- prop.table(table(neuron$SingleR_Vectorseq, neuron$subtype), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = rev(tmp.x)),
    Var2 = factor(Var2, levels = rev(tmp.y)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none') +
  labs(title = 'Predicted Vector-seq sub-types in SC (current study)',
       subtitle = 'Rows sum to 100; Not all boxes labeled.') +
  ylab(label = 'Neuron sub-types in current study\n(query data)') + 
  xlab(label = 'Vector-seq published annotations\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'SingleR_vectorseq-ref-neuron-query_percent-heatmap-ordered.tiff'), plot = p.singler.prop, device = 'tiff', height = 6, width = 8)
p.singler.prop
```

Prediction UMAP

```{r}
#| fig.height: 5
#| fig.width: 6
p.singler.umap <- DimPlot(neuron, group.by = 'SingleR_Vectorseq', pt.size = 1.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Predicted Vector-seq sub-types in SC (current study)') +
  # scale_color_manual(values = neuron.cols) +
  theme(legend.text = element_text(size = 12)) +
  guides(color = guide_legend(override.aes = list(size = 5))) 
p.singler.umap <- umap.axes + p.singler.umap + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'SingleR_vectorseq-ref-neuron-query_prediction-umap.tiff'), plot = p.singler.umap, device = 'tiff', height = 5, width = 6, dpi = 320)
p.singler.umap
```

Stacked bargraph

```{r}
#| fig.height: 3
#| fig.width: 4
p.time <- table(neuron$SingleR_Vectorseq, neuron$time) %>% 
  as.data.frame() %>% 
  ggplot(mapping = aes(x = Var2, y = Freq)) + 
  geom_bar(mapping = aes(fill = Var1), position = 'stack', stat = 'identity',
           color = 'black') +
  scale_fill_discrete(name = 'Predicted\nVector-seq\nclass') +
  ylab(label = 'Cell count') + 
  xlab(label = 'Current study time-point') + 
  theme_bw() +
  theme(legend.position = 'none')
ggsave(filename = paste0(results_out, 'SingleR_vectorseq-ref-neuron-query_prediction-time-barplot.tiff'), plot = p.time, device = 'tiff', height = 3, width = 3, dpi = 320)
p.time
```


## Integrated analysis

The Vector-seq dataset contains `r ncol(cheung.neuron)` neurons, whereas the current study has `r ncol(neuron)` neurons. This imbalance in cell sample sizes can bias sub-type classification - variable features will be weighted more towards features that are variable in the Vector-seq dataset rather than both datasets combined. To mitigate this, we test whether downsampling the cell sample sizes produces similar results to the unsampled Vector-seq data.

```{r}
cheung.neuron.index <- which(cheung$celltype %in% c('Ex.Neuron', 'Inh.Neuron'))
cheung.neuron.downsample <- cheung[, sample(cheung.neuron.index, size = ncol(neuron), replace = FALSE)]
dim(cheung.neuron.downsample)
downsample.dimplot <- umap.axes + (DimPlot(cheung.neuron.downsample, label = TRUE, label.size = 5) + theme_void() + NoLegend()) + plot_layout(design = layout)
downsample.dimplot
```

### Check for batch effects

We re-process the downsample data to examine whether batch effects need to be normalized by sample number.

```{r}
#| fig.height: 4.5
#| fig.width: 5
cheung.neuron.downsample <- cheung.neuron.downsample %>% 
  NormalizeData() %>% 
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA() %>% 
  FindNeighbors(dims = 1:15) %>% 
  FindClusters() %>% 
  RunUMAP(dims = 1:15)
p.batch <- umap.axes + (DimPlot(cheung.neuron.downsample, group.by = 'sample_number', shuffle = TRUE) + theme_void()) + plot_layout(design = layout)
p.batch
```

Using the raw counts, there does not appear to be significant batch effects to correct for between samples within the VectorSeq dataset. We can proceed with integration whereby the each sample of the current study and the downsample VectorSeq data are each considered a batch. 

```{r}
# `orig.ident` stores information on batch
cheung.neuron.downsample$orig.ident <- 'VectorSeq'
merged <- merge(neuron, cheung.neuron.downsample)
table(merged$orig.ident)
not.shared1 <- setdiff(rownames(neuron), rownames(cheung.neuron.downsample))
not.shared2 <- setdiff(rownames(cheung.neuron.downsample), rownames(neuron))
not.shared <- union(not.shared1, not.shared2); rm(not.shared1, not.shared2)
shared <- intersect(rownames(neuron), rownames(cheung.neuron.downsample))
```

```{r}
merged <- NormalizeData(merged)
tmp <- merged
merged@meta.data %>% 
  group_by(orig.ident) %>% 
  summarise(meanFeature = mean(nFeature_RNA))
merged <- SplitObject(merged, split.by = 'orig.ident')
merged_sce <- SingleCellExperiment(
  assays = list(counts = tmp@assays$RNA@counts,
                logcounts = tmp@assays$RNA@data)
)
colData(merged_sce) <- cbind(colData(merged_sce), tmp@meta.data)
gene.stats <- scran::modelGeneVar(x = merged_sce, block = merged_sce$orig.ident)
merged.feats <- getTopHVGs(stats = gene.stats, fdr.threshold = 0.05)
anchor.feats <- merged.feats[merged.feats %in% shared]
anchors <- FindIntegrationAnchors(object.list = merged, anchor.features = anchor.feats, normalization.method = 'LogNormalize')
merged <- IntegrateData(anchorset = anchors, features = anchor.feats, normalization.method = 'LogNormalize')
DefaultAssay(merged) <- 'integrated'
merged <- merged %>% 
  ScaleData() %>% 
  RunPCA()
ElbowPlot(merged, ndims = 40)
merged <- merged %>% 
  FindNeighbors(dims = 1:15) %>% 
  RunUMAP(dims = 1:15)
```


### Results

```{r}
#| fig.height: 5
#| fig.width: 6
p.vectorseq <- DimPlot(
  object = merged, 
  group.by = 'orig.ident',
  shuffle = TRUE,
  pt.size = 0.5
  ) + 
  theme_void() + 
  labs(title = 'Cells colored by sample') +
  scale_color_manual(values = c("#ca4aa6",
                                "#6bc054",
                                "#7252c4",
                                "#c7a636",
                                "#ce4c3e")) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.vectorseq <- umap.axes + p.vectorseq + plot_layout(design = layout)
p.vectorseq
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap.tiff'), plot = p.vectorseq, device = 'tiff', height = 5, width = 6, dpi = 320)
```

```{r}
#| fig.height: 5
#| fig.width: 6
merged$study <- ifelse(
  test = merged$orig.ident %in% c('E19', 'P4', 'P8', 'P21'),
  yes = 'Current',
  no = 'Vector-seq'
)
p.study <- DimPlot(merged, group.by = 'study', shuffle = TRUE, pt.size = 0.5) +
  theme_void() +
  labs(title = 'Cells colored by study') +
  theme(legend.text = element_text(size = 10)) +
  scale_color_manual(values = c('Current' = 'black', 'Vector-seq' = 'red')) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.study <- umap.axes + p.study + plot_layout(design = layout)
p.study
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-study.tiff'), plot = p.study, device = 'tiff', height = 5, width = 6, dpi = 320)
```

```{r}
#| fig.height: 5
#| fig.width: 6
p.subtype <- DimPlot(merged, group.by = 'subtype', shuffle = TRUE, pt.size = 0.5) +
  theme_void() +
  labs(title = 'Cells colored by subtype') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.subtype <- umap.axes + p.subtype + plot_layout(design = layout)
p.subtype
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-subtype.tiff'), plot = p.subtype, device = 'tiff', height = 5, width = 6, dpi = 320)
# labeled
p.subtype <- DimPlot(merged, group.by = 'subtype', shuffle = TRUE, pt.size = 0.5, label = TRUE, label.size = 4) +
  theme_void() +
  labs(title = 'Cells colored by subtype') +
  theme(legend.text = element_text(size = 10),
        legend.position = 'none')
p.subtype <- umap.axes + p.subtype + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-subtype-labeled.tiff'), plot = p.subtype, device = 'tiff', height = 5, width = 5, dpi = 320)
```

### Retrograde-labeled neurons distribution

Transgene presence:

```{r}
#| fig.height: 5
#| fig.width: 5.5
merged$transgene_present <- plyr::mapvalues(
  x = merged$transgene_present,
  from = c(0,1),
  to = c('No','Yes')
)
p.transgene_present  <- DimPlot(merged, group.by = 'transgene_present', shuffle = FALSE, pt.size = 0.5) +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme_void() +
  labs(title = 'Cells colored by transgene presence') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.transgene_present  <- umap.axes + p.transgene_present  + plot_layout(design = layout)
p.transgene_present 
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-transgene-presence.tiff'), plot = p.transgene_present, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-tdTomato:

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.AAVrg.CAG.tdTomato  <- FeaturePlot(merged, features = 'AAVrg.CAG.tdTomato', pt.size = 0.5, order = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVrg-CAG-tdTomato detection') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
p.AAVrg.CAG.tdTomato  <- umap.axes + p.AAVrg.CAG.tdTomato  + plot_layout(design = layout)
p.AAVrg.CAG.tdTomato 
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-AAVrg-CAG-tdTomato.tiff'), plot = p.AAVrg.CAG.tdTomato, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-tdTomato presence (Yes or No):

```{r}
#| fig.height: 5
#| fig.width: 5.5
merged$AAVRG.CAG.TDTOMATO <- plyr::mapvalues(
  x = merged$AAVRG.CAG.TDTOMATO,
  from = c(0,1),
  to = c('No','Yes')
)
p.AAVRG.CAG.TDTOMATO  <- DimPlot(merged, group.by = 'AAVRG.CAG.TDTOMATO', pt.size = 0.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVrg-CAG-tdTomato detection (yes or no)') +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.AAVRG.CAG.TDTOMATO  <- umap.axes + p.AAVRG.CAG.TDTOMATO  + plot_layout(design = layout)
p.AAVRG.CAG.TDTOMATO
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-AAVRG-CAG-TDTOMATO-presence.tiff'), plot = p.AAVRG.CAG.TDTOMATO, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-GFP:

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.AAVrg.CAG.GFP  <- FeaturePlot(merged, features = 'AAVrg.CAG.GFP', pt.size = 0.5, order = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVrg-CAG-GFP detection') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
p.AAVrg.CAG.GFP  <- umap.axes + p.AAVrg.CAG.GFP  + plot_layout(design = layout)
p.AAVrg.CAG.GFP
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-AAVrg-CAG-GFP.tiff'), plot = p.AAVrg.CAG.GFP, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-GFP presence (Yes or No):

```{r}
#| fig.height: 5
#| fig.width: 5.5
merged$AAVRG.CAG.GFP <- plyr::mapvalues(
  x = merged$AAVRG.CAG.GFP,
  from = c(0,1),
  to = c('No','Yes')
)
p.AAVRG.CAG.GFP  <- DimPlot(merged, group.by = 'AAVRG.CAG.GFP', pt.size = 0.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVRG-CAG-GFP detection (yes or no)') +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.AAVRG.CAG.GFP  <- umap.axes + p.AAVRG.CAG.GFP  + plot_layout(design = layout)
p.AAVRG.CAG.GFP
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-AAVRG-CAG-GFP-presence.tiff'), plot = p.AAVRG.CAG.GFP, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

HSV-Cre:

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.HSV.Cre  <- FeaturePlot(merged, features = 'HSV.Cre', pt.size = 0.5, order = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by HSV-Cre detection') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
p.HSV.Cre  <- umap.axes + p.HSV.Cre  + plot_layout(design = layout)
p.HSV.Cre
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-HSV-Cre.tiff'), plot = p.HSV.Cre, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

HSV-Cre presence (Yes or No):

```{r}
#| fig.height: 5
#| fig.width: 5.5
merged$HSV.CRE <- plyr::mapvalues(
  x = merged$HSV.CRE,
  from = c(0,1),
  to = c('No','Yes')
)
p.HSV.CRE  <- DimPlot(merged, group.by = 'HSV.CRE', pt.size = 0.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by HSV-CRE detection (yes or no)') +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.HSV.CRE  <- umap.axes + p.HSV.CRE  + plot_layout(design = layout)
p.HSV.CRE
ggsave(filename = paste0(results_out, 'vectorseq-downsampled-integrated-umap-HSV-CRE-presence.tiff'), plot = p.HSV.CRE, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

```{r}
g <- 'Pitx2'
p <- FeaturePlot(merged, feature = g, order = TRUE, pt.size = 1) +
  theme_void() +
  labs(title = g) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p <- umap.axes + p + plot_layout(design = layout)
p | p.AAVrg.CAG.tdTomato
```


# Xie et al. 2021: Transcriptomic encoding of sensorimotor transformation in the midbrain

Study: [Zhiyong Xie Mengdi Wang Zeyuan Liu Congping Shang Changjiang Zhang Le Sun Huating Gu Gengxin Ran Qing Pei Qiang Ma Meizhu Huang Junjing Zhang Rui Lin Youtong Zhou Jiyao Zhang Miao Zhao Minmin Luo Qian Wu Peng Cao Xiaoqun Wang (2021) Transcriptomic encoding of sensorimotor transformation in the midbrain eLife 10:e69825.](https://doi.org/10.1038/s41593-022-01068-8)

From the abstract:

> Here, we performed high-throughput and circuit-specific single-cell transcriptomic analyses of neurons in the superior colliculus (SC), a midbrain structure implicated in early sensorimotor transformation. Of particular interest, Cbln2 and Pitx2 were key markers that define glutamatergic projection neurons in the optic nerve (Op) and intermediate gray (InG) layers, respectively.

This snRNAseq dataset is provided as `barcodes.tsv.gz`/`features.tsv.gz`/`matrix.mtx.gz` on [GEO with accession GSE162404](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE162404). The files needed to be downloaded and processed.


## Import and preprocess data

```{r}
dir.create(path = 'ref/Xie-et-al-2021/')
download.file(url = 'https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE162404&format=file&file=GSE162404%5Fmatrix%2Emtx%2Egz', destfile = 'ref/Xie-et-al-2021/matrix.mtx.gz')
download.file(url = 'https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE162404&format=file&file=GSE162404%5Ffeatures%2Etsv%2Egz', destfile = 'ref/Xie-et-al-2021/features.tsv.gz')
download.file(url = 'https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE162404&format=file&file=GSE162404%5Fbarcodes%2Etsv%2Egz', destfile = 'ref/Xie-et-al-2021/barcodes.tsv.gz')
```

### QC and doublet removal

```{r}
xie <- Seurat::Read10X(data.dir = 'ref/Xie-et-al-2021/')
xie <- CreateSeuratObject(
  counts = xie,
  project = 'Xie-et-al-2021'
)
xie$SampleID <- paste0('sample', sapply(strsplit(colnames(xie), '-'), `[[`, 2))
xie <- PercentageFeatureSet(xie, '^mt-', col.name = 'percent_mt')
xie <- SplitObject(xie, split.by = 'SampleID')
```

```{r doublet-removal-setup}
doublet_rate <- read.table(file = 'ref/DoubletRates_10x.tsv', header = TRUE)
doublet_rate <- lm(Multiplet_rate ~ nCells_Recovered, data = doublet_rate)
compute_rate <- function(x) {
  return(doublet_rate$coefficients[1] + doublet_rate$coefficients[2] * x)
}
# Import package and std_out config details.
scrublet_out <- paste0(results_out, 'scrublet_outs/')
dir.create(path = scrublet_out)
scrub <- import(module = 'scrublet', convert = FALSE)
```

```{r run-scrublet}
# Run Scrublet 
doublet_results <- vector(mode = 'list', length = length(xie))
names(doublet_results) <- names(xie)
for (id in 1:length(xie)) {
  message('running Scrublet on:', id)
  tmp_rate <- compute_rate(x = ncol(xie[[id]]))
  tmp_scrublet <- scrub$Scrublet(
    counts_matrix = r_to_py(
      x = Matrix::t(xie[[id]][['RNA']]@counts))$tocsc(),
    expected_doublet_rate = tmp_rate
  )
  scrublet_result <- py_capture_output(
    tmp_scrublet$scrub_doublets(
      min_counts = 2,
      min_cells = 3,
      min_gene_variability_pctl = 85,
      verbose = TRUE
    )
  )
  writeLines(
    text = c(id, scrublet_result),
    con = paste0(results_out, 'Xie-et-al-2021_scrublet_outs/', id, '.txt')
  )
  scores <- py_to_r(tmp_scrublet$doublet_scores_obs_)
  # More stringent doublet score filtering
  threshold <- py_to_r(tmp_scrublet$threshold_) * 0.85
  doublet_results[[id]][['doublet_score']] <- py_to_r(tmp_scrublet$doublet_scores_obs_)
  doublet_results[[id]][['is_doublet']] <- doublet_results[[id]][['doublet_score']] > threshold
  names(doublet_results[[id]]) <- c('doublet_score', 'is_doublet')
  doublet_results[[id]][['Threshold_score']] <- threshold
  gc()
}
```

```{r doublet_results}
#| fig.height: 5
#| fig.width: 10
#| fig.cap: Distribution of doublet scores by sample. Higher per-cell scores indicate greater likelihood of being a doublet. Red line indicates score thresholds for classifying doublets.
doublet.histograms <- vector(mode = 'list', length = length(doublet_results))
names(doublet.histograms) <- names(doublet_results)
for (id in names(doublet_results)) {
  doublet.histograms[[id]] <- data.frame('score'=doublet_results[[id]]$doublet_score) %>%
    ggplot(mapping = aes(x = score)) +
    geom_histogram(mapping = aes(x = score), binwidth = 0.01) + 
    geom_vline(xintercept = doublet_results[[id]]$Threshold_score,
               linetype = 'dashed', col = 'indianred', linewidth = 1) + 
    scale_y_continuous(trans = 'log10', breaks = 10^seq(-5, 5, 1)) + 
    labs(title = id, subtitle = 'Scrublet scores') + 
    ylab(label = 'Cell count') +  
    xlab(label = 'Doublet score') + 
    theme_bw() + 
    theme(title = element_text(size = 8))
}
doublet.histograms <- cowplot::plot_grid(plotlist = doublet.histograms, ncol = length(xie), byrow = FALSE)
doublet.histograms
ggsave(filename = paste0(results_out, 'Xie-et-al-2021_scrublet_outs/', 'Xie-et-al-2021_Scrublet_score_hist.tiff'),
       plot = doublet.histograms, height = 2.5, width = 6, device = 'tiff')
doublet.histograms
```

```{r}
whitelist.scrublet <- vector(mode = 'list', length = length(xie))
names(whitelist.scrublet) <- names(xie)
for (i in 1:length(xie)) {
  keep.i <- which(!doublet_results[[i]]$is_doublet)
  whitelist.scrublet[[i]] <- colnames(xie[[i]])[keep.i]
}
```

```{r doublet_summary}
# Summary of doublet call results
knitr::kable(x = t(sapply(doublet_results, 
                          FUN = function(x) table(x[['is_doublet']]))),
             caption = 'Scrublet summary: is doublet?')
```

```{r}
for (i in 1:length(xie)) {
  xie[[i]] <- xie[[i]][, whitelist.scrublet[[i]]]
  xie[[i]] <- xie[[i]][, xie[[i]]$nFeature_RNA <= 6000 & xie[[i]]$nFeature_RNA >= 800]
  xie[[i]] <- xie[[i]][, xie[[i]]$nCount_RNA <= 20000]
  xie[[i]] <- xie[[i]][, xie[[i]]$percent_mt <= 3]
}
```

```{r}
xie <- lapply(xie, NormalizeData)
xie <- lapply(xie, FindVariableFeatures, nfeatures = 4000)
xie.feats <- SelectIntegrationFeatures(xie, nfeatures = 3000)
xie.anchors <- FindIntegrationAnchors(xie, anchor.features = xie.feats)
xie <- IntegrateData(anchorset = xie.anchors, features = xie.feats)
DefaultAssay(xie) <- 'integrated'; rm(xie.anchors)
xie <- xie %>% 
  ScaleData() %>% 
  RunPCA() %>% 
  FindNeighbors(dims = 1:10) %>% 
  RunUMAP(dims = 1:10) %>% 
  FindClusters()
```


```{r}
p1 <- DimPlot(xie, shuffle = TRUE, group.by = 'SampleID')
p2 <- DimPlot(xie, label = TRUE, label.size = 4, shuffle = TRUE)
p3 <- DotPlot(xie, assay = 'RNA', features = c('Atp1a2','Gfap','Mog','Sox9','Sox10','Cx3cr1','Thy1','Gad1','Slc17a6','Cldn5','Pdgfrb','Foxj1','Ttr')) + 
  theme(axis.text.x = element_text(angle = 65, hjust = 1))
xie.summary <- p1 | p2 | p3
xie.summary
ggsave(filename = paste0(results_out, 'Xie-et-al-2021_summary.tiff'), plot = xie.summary, device = 'tiff', height = 5, width = 13, dpi = 320)
```



## Integrated analysis

```{r}
DefaultAssay(sc) <- 'RNA'
DefaultAssay(xie) <- 'RNA'
sc$SampleID <- as.character(sc$time)
xie$SampleID <- as.character(xie$SampleID)
merged <- merge(sc, xie)
merged$SampleID <- ifelse(
  test = is.na(merged$SampleID),
  yes = as.character(merged$orig.ident),
  no = merged$SampleID
)
not.shared1 <- setdiff(rownames(sc), rownames(xie))
not.shared2 <- setdiff(rownames(xie), rownames(sc))
not.shared <- union(not.shared1, not.shared2); rm(not.shared1, not.shared2)
shared <- intersect(rownames(sc), rownames(xie))
```


* *Gfap* is in `not.shared`: `r 'Gfap' %in% not.shared`
* *Cxcr1* is in `not.shared`: `r 'Cxcr1' %in% not.shared`


```{r}
FetchData(merged, c('Gfap','Slc17a6','SampleID')) %>% 
  group_by(SampleID) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(sc, c('Gfap','Slc17a6','SampleID')) %>% 
  group_by(SampleID) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(xie, c('Gfap','Slc17a6','SampleID')) %>% 
  group_by(SampleID) %>% 
  summarise(across(where(is.numeric), mean))
```

```{r}
FetchData(merged, c('Gfap','Cxcr1','SampleID')) %>% 
  group_by(SampleID) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(sc, c('Gfap','Cxcr1','SampleID')) %>% 
  group_by(SampleID) %>% 
  summarise(across(where(is.numeric), mean))
FetchData(xie, c('Gfap','Cxcr1','SampleID')) %>% 
  group_by(SampleID) %>% 
  summarise(across(where(is.numeric), mean))
```


Based on these outputs, running `merge` on the two `Seurat` objects yields another `Seurat` object whereby features that were not present in both datasets, e.g. *Cxcr1.*, are filled with zero counts.


```{r}
tmp <- merged
merged@meta.data %>% 
  group_by(SampleID) %>% 
  summarise(meanFeature = mean(nFeature_RNA))
merged <- SplitObject(merged, split.by = 'SampleID')
merged <- lapply(merged, NormalizeData)

merged_sce <- SingleCellExperiment(
  assays = list(counts = tmp@assays$RNA@counts,
                logcounts = tmp@assays$RNA@data)
)
colData(merged_sce) <- cbind(colData(merged_sce), tmp@meta.data)
gene.stats <- scran::modelGeneVar(x = merged_sce, block = merged_sce$SampleID)
merged.feats <- getTopHVGs(stats = gene.stats, fdr.threshold = 0.05)
anchor.feats <- merged.feats[merged.feats %in% shared]
anchors <- FindIntegrationAnchors(object.list = merged, anchor.features = anchor.feats, normalization.method = 'LogNormalize')
merged <- IntegrateData(anchorset = anchors, features = anchor.feats, normalization.method = 'LogNormalize')
DefaultAssay(merged) <- 'integrated'
merged <- merged %>% 
  ScaleData() %>% 
  RunPCA()
ElbowPlot(merged, ndims = 40)
merged <- merged %>% 
  FindNeighbors(dims = 1:15) %>% 
  RunUMAP(dims = 1:15)
```


### Results

```{r}
#| fig.height: 5
#| fig.width: 6
p.xie <- DimPlot(
  object = merged, 
  group.by = 'SampleID',
  shuffle = TRUE,
  pt.size = 1
  ) + 
  theme_void() + 
  labs(title = 'Cells colored by sample') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.xie <- umap.axes + p.xie + plot_layout(design = layout)
p.xie
ggsave(filename = paste0(results_out, 'xie-integrated-umap.tiff'), plot = p.xie, device = 'tiff', height = 5, width = 6, dpi = 320)
```


```{r}
#| fig.height: 5
#| fig.width: 6
merged$study <- ifelse(
  test = merged$SampleID %in% c('E19', 'P4', 'P8', 'P21'),
  yes = 'Current',
  no = 'Xie-et-al'
)
p.study <- DimPlot(merged, group.by = 'study', shuffle = TRUE, pt.size = 1) +
  theme_void() +
  labs(title = 'Cells colored by study') +
  theme(legend.text = element_text(size = 10)) +
  scale_color_manual(values = c('Current' = 'black', 'Xie-et-al' = 'red')) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.study <- umap.axes + p.study + plot_layout(design = layout)
p.study
ggsave(filename = paste0(results_out, 'xie-integrated-umap-study.tiff'), plot = p.study, device = 'tiff', height = 5, width = 6, dpi = 320)
```


```{r}
#| fig.height: 5
#| fig.width: 6
p.celltype <- DimPlot(merged, group.by = 'celltype', shuffle = TRUE, pt.size = 1) +
  theme_void() +
  labs(title = 'Cells colored by celltype') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.celltype <- umap.axes + p.celltype + plot_layout(design = layout)
p.celltype
ggsave(filename = paste0(results_out, 'xie-integrated-umap-celltype.tiff'), plot = p.celltype, device = 'tiff', height = 5, width = 7, dpi = 320)
```



# Integrating multiple SC sources

Trans-seq attempted to identify the neurons in the superior colliculus onto which RGCs project using a trans-synaptic anterograde viral tracer. On the other hand, Vector-seq attempted to identify neurons from the superior colliculus, among other brain regions, that project to other brain regions involved in visual processing. Our current dataset captures the developmental heterogeneity of neurons in the superior colliculus. By leveraging and integrating these data, we can test whether a shared neuronal sub-type can be isolated that both receives projections from RGCs and subsequently projects onto visual processing brain regions.

## Import and process data

```{r}
# load
load(file = 'ref/AllPanRGCClustered.RData')
neuron <- readRDS(file = 'data/neuron.rds')
cheung <- LoadH5Seurat(file = 'ref/Cheung-et-al-2021/processed/processed/all/adata.h5seurat')
# trans-seq metadata wrangling
allpan_slcgad$subtype <- Idents(allpan_slcgad)
# vector-seq metadata wrangling
cheung.metadata <- read.csv(file = paste0(results_out, 'Cheung-et-al-2021_metadata.csv'), row.names = 1)
if (identical(rownames(cheung.metadata), rownames(cheung@meta.data))) {
  cheung@meta.data <- cheung.metadata
  message('meta.data added')
}
# use `orig.ident` as batch-containing vector.
cheung$orig.ident <- 'VectorSeq'
# downsample for integration
cheung.neuron.index <- which(cheung$celltype %in% c('Ex.Neuron', 'Inh.Neuron'))
cheung.neuron.downsample <- cheung[, sample(cheung.neuron.index, size = ncol(neuron), replace = FALSE)]
```

## Integrated analysis

As previously described, the Trans-seq data contains significant batch effects between samples. Our data also contains significant batch effects by developmental time-point. The Vector-seq data does not contain significant effects between samples. Our integration will attempt to account for these sources of unwanted variation.

```{r}
DefaultAssay(neuron) <- 'RNA'
DefaultAssay(allpan_slcgad) <- 'RNA'
DefaultAssay(cheung.neuron.downsample) <- 'RNA'
shared.genes <- Reduce(
  f = intersect, 
  x = sapply(X = list(neuron, allpan_slcgad, cheung.neuron.downsample), 
             FUN = rownames)
)
sc.atlas <- Reduce(f = merge, x = list(neuron, allpan_slcgad, cheung.neuron.downsample))
rm(neuron, allpan_slcgad, cheung.neuron.downsample, cheung)
DefaultAssay(sc.atlas) <- 'RNA'
sc.atlas <- NormalizeData(sc.atlas)
sc.atlas.sce <- SingleCellExperiment(
  assays = list(counts = sc.atlas@assays$RNA@counts,
                logcounts = sc.atlas@assays$RNA@data)
)
colData(sc.atlas.sce) <- cbind(colData(sc.atlas.sce), sc.atlas@meta.data)
gene.stats <- scran::modelGeneVar(
  x = sc.atlas.sce, 
  block = sc.atlas.sce$orig.ident
)
merged.feats <- getTopHVGs(stats = gene.stats, fdr.threshold = 0.05)
anchor.feats <- merged.feats[merged.feats %in% shared.genes]
sc.atlas <- SplitObject(sc.atlas, split.by = 'orig.ident')
anchors <- FindIntegrationAnchors(
  object.list = sc.atlas,
  anchor.features = anchor.feats,
  normalization.method = 'LogNormalize'
)
sc.atlas <- IntegrateData(
  anchorset = anchors,
  features = anchor.feats,
  normalization.method = 'LogNormalize'
)
DefaultAssay(sc.atlas) <- 'integrated'
sc.atlas <- sc.atlas %>% 
  ScaleData() %>% 
  RunPCA()
ElbowPlot(sc.atlas, ndims = 40)
sc.atlas <- sc.atlas %>% 
  FindNeighbors(dims = 1:20) %>% 
  RunUMAP(dims = 1:20)
```

### SC atlas meta-data

```{r}
# metadata wrangling for plotting
sc.atlas$study <- NA
sc.atlas$study <- ifelse(
  test = sc.atlas$orig.ident %in% c('E19', 'P4', 'P8', 'P21'),
  yes = 'Current',
  no = sc.atlas$study
)
sc.atlas$study <- ifelse(
  test = sc.atlas$orig.ident %in% c('Pan_RGC_1','Pan_RGC_2','Pan_RGC_3'),
  yes = 'TransSeq',
  no = sc.atlas$study
)
sc.atlas$study <- ifelse(
  test = sc.atlas$orig.ident %in% c('VectorSeq'),
  yes = 'VectorSeq',
  no = sc.atlas$study
)
sc.atlas$subtype <- ifelse(
  test = sc.atlas$study %in% c('TransSeq', 'VectorSeq'),
  yes = NA,
  no = sc.atlas$subtype
)
sc.atlas$transgene_present <- plyr::mapvalues(
  x = sc.atlas$transgene_present,
  from = c(0,1),
  to = c('No','Yes')
)
sc.atlas$transgene_present <- factor(sc.atlas$transgene_present, levels = c('No','Yes'))
sc.atlas$AAVRG.CAG.TDTOMATO <- plyr::mapvalues(
  x = sc.atlas$AAVRG.CAG.TDTOMATO,
  from = c(0,1),
  to = c('No','Yes')
)
sc.atlas$AAVRG.CAG.TDTOMATO <- factor(sc.atlas$AAVRG.CAG.TDTOMATO, levels = c('No','Yes'))
sc.atlas$AAVRG.CAG.GFP <- plyr::mapvalues(
  x = sc.atlas$AAVRG.CAG.GFP,
  from = c(0,1),
  to = c('No','Yes')
)
sc.atlas$AAVRG.CAG.GFP <- factor(sc.atlas$AAVRG.CAG.GFP, levels = c('No','Yes'))
sc.atlas$HSV.CRE <- plyr::mapvalues(
  x = sc.atlas$HSV.CRE,
  from = c(0,1),
  to = c('No','Yes')
)
sc.atlas$HSV.CRE <- factor(sc.atlas$HSV.CRE, levels = c('No','Yes'))
```

### Results

```{r}
#| fig.height: 5
#| fig.width: 6
p.atlas <- DimPlot(
  object = sc.atlas, 
  group.by = 'orig.ident',
  shuffle = TRUE,
  pt.size = 0.5
  ) + 
  theme_void() + 
  labs(title = 'Cells colored by sample (batch)') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.atlas <- umap.axes + p.atlas + plot_layout(design = layout)
p.atlas
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap.tiff'), plot = p.atlas, device = 'tiff', height = 5, width = 6, dpi = 320)
```

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.study <- DimPlot(sc.atlas, group.by = 'study', shuffle = TRUE, pt.size = 0.5) +
  theme_void() +
  labs(title = 'Cells colored by study') +
  theme(legend.text = element_text(size = 10)) +
  scale_color_manual(values = c('Current' = 'black', 
                                'VectorSeq' = 'indianred',
                                'TransSeq' = 'dodgerblue')) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.study <- umap.axes + p.study + plot_layout(design = layout)
p.study
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-study.tiff'), plot = p.study, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

```{r}
#| fig.height: 5
#| fig.width: 5
p.subtype <- DimPlot(sc.atlas, group.by = 'subtype', shuffle = TRUE, pt.size = 0.5) +
  theme_void() +
  labs(title = 'Cells colored by subtype') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.subtype <- umap.axes + p.subtype + plot_layout(design = layout)
p.subtype
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-subtype.tiff'), plot = p.subtype, device = 'tiff', height = 5, width = 6, dpi = 320)
# labeled
p.subtype <- DimPlot(sc.atlas, group.by = 'subtype', shuffle = TRUE, pt.size = 0.5, label = TRUE, label.size = 4) +
  theme_void() +
  labs(title = 'Cells colored by subtype') +
  theme(legend.text = element_text(size = 10),
        legend.position = 'none')
p.subtype <- umap.axes + p.subtype + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-subtype-labeled.tiff'), plot = p.subtype, device = 'tiff', height = 5, width = 5, dpi = 320)
```

### Retrograde-labeled neurons distribution

Transgene presence:

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.transgene_present  <- DimPlot(sc.atlas, group.by = 'transgene_present', shuffle = FALSE, pt.size = 0.5) +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme_void() +
  labs(title = 'Cells colored by transgene presence') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.transgene_present  <- umap.axes + p.transgene_present  + plot_layout(design = layout)
p.transgene_present 
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-transgene-presence.tiff'), plot = p.transgene_present, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-tdTomato:

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.AAVrg.CAG.tdTomato  <- FeaturePlot(sc.atlas, features = 'AAVrg.CAG.tdTomato', pt.size = 0.5, order = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVrg-CAG-tdTomato detection') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
p.AAVrg.CAG.tdTomato  <- umap.axes + p.AAVrg.CAG.tdTomato  + plot_layout(design = layout)
p.AAVrg.CAG.tdTomato 
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-AAVrg-CAG-tdTomato.tiff'), plot = p.AAVrg.CAG.tdTomato, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-tdTomato presence (Yes or No):

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.AAVRG.CAG.TDTOMATO  <- DimPlot(sc.atlas, group.by = 'AAVRG.CAG.TDTOMATO', pt.size = 0.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVrg-CAG-tdTomato detection (yes or no)') +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.AAVRG.CAG.TDTOMATO  <- umap.axes + p.AAVRG.CAG.TDTOMATO  + plot_layout(design = layout)
p.AAVRG.CAG.TDTOMATO
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-AAVRG-CAG-TDTOMATO-presence.tiff'), plot = p.AAVRG.CAG.TDTOMATO, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-GFP:

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.AAVrg.CAG.GFP  <- FeaturePlot(sc.atlas, features = 'AAVrg.CAG.GFP', pt.size = 0.5, order = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVrg-CAG-GFP detection') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
p.AAVrg.CAG.GFP  <- umap.axes + p.AAVrg.CAG.GFP  + plot_layout(design = layout)
p.AAVrg.CAG.GFP
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-AAVrg-CAG-GFP.tiff'), plot = p.AAVrg.CAG.GFP, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

AAVrg-CAG-GFP presence (Yes or No):

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.AAVRG.CAG.GFP  <- DimPlot(sc.atlas, group.by = 'AAVRG.CAG.GFP', pt.size = 0.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by AAVRG-CAG-GFP detection (yes or no)') +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.AAVRG.CAG.GFP  <- umap.axes + p.AAVRG.CAG.GFP  + plot_layout(design = layout)
p.AAVRG.CAG.GFP
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-AAVRG-CAG-GFP-presence.tiff'), plot = p.AAVRG.CAG.GFP, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

HSV-Cre:

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.HSV.Cre  <- FeaturePlot(sc.atlas, features = 'HSV.Cre', pt.size = 0.5, order = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by HSV-Cre detection') +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
p.HSV.Cre  <- umap.axes + p.HSV.Cre  + plot_layout(design = layout)
p.HSV.Cre
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-HSV-Cre.tiff'), plot = p.HSV.Cre, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```

HSV-Cre presence (Yes or No):

```{r}
#| fig.height: 5
#| fig.width: 5.5
p.HSV.CRE  <- DimPlot(sc.atlas, group.by = 'HSV.CRE', pt.size = 0.5, shuffle = TRUE) +
  theme_void() +
  labs(title = 'Cells colored by HSV-CRE detection (yes or no)') +
  scale_color_manual(values = c('No' = 'black', 'Yes' = 'red')) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p.HSV.CRE  <- umap.axes + p.HSV.CRE  + plot_layout(design = layout)
p.HSV.CRE
ggsave(filename = paste0(results_out, 'sc-atlas-downsampled-integrated-umap-HSV-CRE-presence.tiff'), plot = p.HSV.CRE, device = 'tiff', height = 5, width = 5.5, dpi = 320)
```


```{r}
g <- 'Pitx2'
p <- FeaturePlot(merged, feature = g, order = TRUE, pt.size = 1) +
  theme_void() +
  labs(title = g) +
  theme(legend.text = element_text(size = 10)) +
  guides(color = guide_legend(override.aes = list(size = 5)))
p <- umap.axes + p + plot_layout(design = layout)
p | p.AAVrg.CAG.tdTomato
```


# Figure 5

## Figure 5A

```{r}
# Figure 5A: method schematic
p.gray <- DimPlot(transseq, pt.size = 1) +
  scale_color_manual(values = rep('grey', 20)) +
  theme_void() + 
  theme(legend.position = 'none')
ggsave(filename = paste0(results_out, 'Figure5A_schematic-query-umap.tiff'), plot = p.gray, device = 'tiff', height = 2, width = 2, dpi = 320)
p.ref <- DimPlot(neuron, group.by = 'subtype', pt.size = 0.5) +
  scale_color_manual(values = neuron.cols) +
  theme_void() + 
  theme(legend.position = 'none',
        plot.title = element_blank())
ggsave(filename = paste0(results_out, 'Figure5A_schematic-reference-umap.tiff'), plot = p.ref, device = 'tiff', height = 2, width = 2, dpi = 320)
# Trans-seq annotation without labels/legend
p.annotated <- DimPlot(transseq, group.by = 'SingleR_sc.neuron', pt.size = 1, shuffle = TRUE) +
  theme_void() +
  scale_color_manual(values = neuron.cols) +
  theme(legend.position = 'none',
        plot.title = element_blank())
ggsave(filename = paste0(results_out, 'Figure5A_schematic-annotated-umap.tiff'), plot = p.annotated, device = 'tiff', height = 2, width = 2, dpi = 320)
# Plots were then manually laid out in powerpoint for editing/formatting
```

## Figure 5B

```{r}
figure5b <- DimPlot(transseq, group.by = 'SingleR_sc.neuron', pt.size = 3, shuffle = TRUE, label = TRUE, label.size = 4, repel = TRUE) +
  theme_void() +
  labs(title = 'Predicted neuron sub-types in Trans-Seq') +
  scale_color_manual(values = neuron.cols) +
  # theme(legend.text = element_text(size = 12)) +
  theme(legend.position = 'none') +
  guides(color = guide_legend(override.aes = list(size = 5))) 
figure5b <- umap.axes + figure5b + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'Figure5B_transseq-neuron-prediction-umap.tiff'), plot = figure5b, device = 'tiff', height = 5, width = 5, dpi = 320)
```

## Figure 5C

```{r}
#| fig.height: 5
#| fig.width: 6
figure5c <- prop.table(table(transseq$SingleR_sc.neuron, transseq$subtype), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = levels(neuron$subtype)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0, 100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none',
                     drop = FALSE) +
  ylab(label = 'Trans-seq published\nannotations (query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14)) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
figure5c <- umap.axes + figure5c + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'Figure5C_transseq-neuron-prediction-heatmap.tiff'), plot = figure5c, device = 'tiff', height = 3.75, width = 7, dpi = 320)
```

## Figure 5D

```{r}
figure5d <- DimPlot(vectorseq, group.by = 'SingleR_sc.neuron', pt.size = 0.5, shuffle = TRUE, label = TRUE, label.size = 3.5) +
  theme_void() +
  labs(title = 'Predicted neuron sub-types in Vector-Seq') +
  scale_color_manual(values = neuron.cols) +
  theme(legend.position = 'none') +
  guides(color = guide_legend(override.aes = list(size = 5))) 
figure5d <- umap.axes + figure5d + plot_layout(design = layout)
ggsave(filename = paste0(results_out, 'Figure5D_vectorseq-neuron-prediction-umap.tiff'), plot = figure5d, device = 'tiff', height = 5, width = 4.75, dpi = 320)
```

## Figure 5E

```{r}
tmp <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$leiden_0.6), margin = 2)
tmp.x <- dendsort::dendsort(d = hclust(d = dist(tmp)))
tmp.x <- tmp.x$labels[tmp.x$order]
tmp.y <- dendsort::dendsort(d = hclust(d = dist(t(tmp))))
tmp.y <- tmp.y$labels[tmp.y$order]
figure5e <- prop.table(table(vectorseq$SingleR_sc.neuron, vectorseq$leiden_0.6), margin = 2) %>% 
  as.data.frame() %>% 
  mutate(
    Var1 = factor(Var1, levels = rev(tmp.x)),
    Var2 = factor(Var2, levels = rev(tmp.y)),
    Percent = round(Freq*100),
    prop.label = ifelse(test = Percent > 1, yes = Percent, no = NA),
    label.color = ifelse(test = Percent > 80, yes = 'dark', no = 'light')) %>% 
  tidyr::complete(Var1, Var2, fill = list(Percent = 0, prop.label = NA)) %>% 
  ggplot(mapping = aes(x = Var1, y = Var2)) +
  geom_tile(mapping = aes(fill = Percent)) +
  geom_text(mapping = aes(label = prop.label, color = label.color), size = 3.5) +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_discrete(expand = c(0,0)) +
  scale_fill_viridis_c(name = 'Predicted\nclass\nproportion', limits = c(0,100)) +
  scale_color_manual(values = c('dark' = 'black', 'light' = 'white'),
                     guide = 'none',
                     drop = FALSE) +
  ylab(label = 'Vector-seq published annotations\n(query data)') + 
  xlab(label = 'Neuron sub-types in current study\n(reference data)') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title = element_text(size = 14),
        legend.text = element_text()) +
  guides(fill = guide_colorbar(frame.colour = 'black', ticks.colour = 'black'))
ggsave(filename = paste0(results_out, 'Figure5E_vectorseq-neuron-prediction-heatmap.tiff'), plot = figure5e, device = 'tiff',  height = 8, width = 7, dpi = 320)
```


```{r}
figure5 <- (cowplot::plot_grid(figure5b, figure5d, ncol = 1)) | ((figure5c / figure5e) + plot_layout(guides = 'collect', heights = c(0.3, 1))) + plot_layout(widths = c(1, 1.2))
ggsave(filename = paste0(results_out, 'Figure5_combined.tiff'), plot = figure5, device = 'tiff', height = 11, width = 11, dpi = 320)
```


# Gene expression confirmation of corresponding subtypes

## Expression of Gpc3 and Sntb1

```{r}
p.gpc3 = FetchData(object = neuron, vars = c('time','subtype','Gpc3'), slot = 'data') %>% 
  ggplot(mapping = aes(x = subtype, y = Gpc3)) + 
  geom_violin(mapping = aes(fill = subtype), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  scale_fill_manual(values = neuron.cols) +
  theme_bw() +
  labs(title = 'Gpc3', y = 'Normalized Expression', x = '') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none')
ggsave(filename = paste0(results_out, 'neuron-expression-gpc3-violin.tiff'), plot = p.gpc3, device = 'tiff', height = 2.5, width = 7, dpi = 320)
p.gpc3
p.sntb1 = FetchData(object = neuron, vars = c('time','subtype','Sntb1'), slot = 'data') %>% 
  ggplot(mapping = aes(x = subtype, y = Sntb1)) + 
  geom_violin(mapping = aes(fill = subtype), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  scale_fill_manual(values = neuron.cols) +
  theme_bw() +
  labs(title = 'Sntb1', y = 'Normalized Expression', x = '') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none') 
ggsave(filename = paste0(results_out, 'neuron-expression-sntb1-violin.tiff'), plot = p.sntb1, device = 'tiff', height = 2.5, width = 7, dpi = 320)
p.sntb1
Figure5fg = p.gpc3 / p.sntb1
ggsave(filename = paste0(results_out, 'Figure5fg_neuron-expression-violin1.tiff'), plot = Figure5fg, device = 'tiff', height = 5, width = 7, dpi = 320)

Figure5fg = FetchData(object = neuron, vars = c('time','subtype','Gpc3','Sntb1'), slot = 'data') %>% 
  reshape2::melt(id.vars = c('time','subtype')) %>% 
  ggplot(mapping = aes(x = subtype, y = value)) + 
  geom_violin(mapping = aes(fill = subtype), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  facet_wrap(. ~ variable, scales = 'free_y', ncol = 2, strip.position = 'top') +
  scale_fill_manual(values = neuron.cols) +
  theme_bw() +
  labs(y = 'Normalized Expression', x = '') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none',
        strip.text = element_text(size = 14))
ggsave(filename = paste0(results_out, 'Figure5fg_neuron-expression-violin2.tiff'), plot = Figure5fg, device = 'tiff', height = 2.5, width = 12, dpi = 320)
```

## Expression of Pitx2

```{r}
p.pitx2 = FetchData(object = neuron, vars = c('time','subtype','Pitx2'), slot = 'data') %>% 
  ggplot(mapping = aes(x = subtype, y = Pitx2)) + 
  geom_violin(mapping = aes(fill = subtype), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  scale_fill_manual(values = neuron.cols) +
  theme_bw() +
  labs(title = 'Pitx2', y = 'Normalized Expression', x = 'Neuron subtypes (current study)') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none',
        axis.title.x = element_text(size = 12))
ggsave(filename = paste0(results_out, 'neuron-expression-pitx2-violin.tiff'), plot = p.pitx2, device = 'tiff', height = 2.75, width = 7, dpi = 320)

p.pitx2.cheungEx = FetchData(object = cheungEx, vars = c('merged_remapped_leid_0.6','Pitx2'), slot = 'data') %>% 
  ggplot(mapping = aes(x = merged_remapped_leid_0.6, y = Pitx2)) + 
  geom_violin(mapping = aes(fill = merged_remapped_leid_0.6), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  theme_bw() +
  labs(title = 'Pitx2', y = 'Normalized Expression', x = 'Vector-seq Excitatory neuron clusters (Cheung et al. figure 3C)') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none',
        axis.title.x = element_text(size = 12))
ggsave(filename = paste0(results_out, 'vectorseq-expression-pitx2-violin.tiff'), plot = p.pitx2.cheungEx, device = 'tiff', height = 2.5, width = 7, dpi = 320)

ggsave(filename = paste0(results_out, 'corresponding-expression-pitx2-violin.tiff'), plot = p.pitx2 / p.pitx2.cheungEx, device = 'tiff', height = 5.25, width = 7, dpi = 320)
p.pitx2 / p.pitx2.cheungEx
```

## Expression of Ntng2 and Cbln

```{r}
# Ntng2
DotPlot(neuron, features = c('Ntng2','Cbln2'))
DotPlot(cheungEx, features = c('Ntng2','Cbln2'))
p.ntng2 = FetchData(object = neuron, vars = c('time','subtype','Ntng2'), slot = 'data') %>% 
  ggplot(mapping = aes(x = subtype, y = Ntng2)) + 
  geom_violin(mapping = aes(fill = subtype), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  scale_fill_manual(values = neuron.cols) +
  theme_bw() +
  labs(title = 'Ntng2', y = 'Normalized Expression', x = 'Neuron subtypes (current study)') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none',
        axis.title.x = element_text(size = 12))
p.ntng2
ggsave(filename = paste0(results_out, 'neuron-expression-ntng2-violin.tiff'), plot = p.ntng2, device = 'tiff', height = 2.75, width = 7, dpi = 320)

p.ntng2.cheungEx = FetchData(object = cheungEx, vars = c('merged_remapped_leid_0.6','Ntng2'), slot = 'data') %>% 
  ggplot(mapping = aes(x = merged_remapped_leid_0.6, y = Ntng2)) + 
  geom_violin(mapping = aes(fill = merged_remapped_leid_0.6), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  theme_bw() +
  labs(title = 'Ntng2', y = 'Normalized Expression', x = 'Vector-seq Excitatory neuron clusters (Cheung et al. figure 3C)') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none',
        axis.title.x = element_text(size = 12))
p.ntng2.cheungEx
ggsave(filename = paste0(results_out, 'vectorseq-expression-ntng2-violin.tiff'), plot = p.ntng2.cheungEx, device = 'tiff', height = 2.5, width = 7, dpi = 320)

# Cbln2
p.cbln2.cheungEx = FetchData(object = cheungEx, vars = c('merged_remapped_leid_0.6','Cbln2'), slot = 'data') %>% 
  ggplot(mapping = aes(x = merged_remapped_leid_0.6, y = Cbln2)) + 
  geom_violin(mapping = aes(fill = merged_remapped_leid_0.6), scale = 'width') +
  ggbeeswarm::geom_quasirandom(
    bandwidth = 0.5, size = 0.1, alpha = 0.3, varwidth = TRUE, width = 0.8) +
  theme_bw() +
  labs(title = 'Cbln2', y = 'Normalized Expression', x = 'Vector-seq Excitatory neuron clusters (Cheung et al. figure 3C)') +
  theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        legend.position = 'none',
        axis.title.x = element_text(size = 12))
p.cbln2.cheungEx




ggsave(filename = paste0(results_out, 'corresponding-expression-cbln2-violin.tiff'), plot = p.pitx2 / p.pitx2.cheungEx, device = 'tiff', height = 5.25, width = 7, dpi = 320)
p.pitx2 / p.pitx2.cheungEx
```


```{r}
p.ntng2 = FeaturePlot(neuron, 'Ntng2', 
                      order = TRUE,
                      pt.size = 0.5, label = TRUE, label.size = 4) +
  scale_color_gradient(low = 'grey90', high = 'red') +
  theme_void() +
  theme(legend.position = 'none') +
  labs(title = 'Ntng2: current study')
p.ntng2 = umap.axes + p.ntng2 + plot_layout(design = layout)
# p.ntng2

p.ntng2.cheungEx = FeaturePlot(cheungEx, 'Ntng2', 
                               order = TRUE,
                               pt.size = 0.25, label = TRUE, label.size = 4) +
  scale_color_gradient(low = 'grey90', high = 'red') +
  theme_void() +
  theme(legend.position = 'none') +
  labs(title = 'Ntng2: Vector-seq')
p.ntng2.cheungEx = umap.axes + p.ntng2.cheungEx + plot_layout(design = layout)
# p.ntng2.cheungEx

p.cbln2 = FeaturePlot(neuron, 'Cbln2', 
                      order = TRUE,
                      pt.size = 0.5, label = TRUE, label.size = 4) +
  scale_color_gradient(low = 'grey90', high = 'red') +
  theme_void() +
  theme(legend.position = 'none') +
  labs(title = 'Cbln2: current study')
p.cbln2 = umap.axes + p.cbln2 + plot_layout(design = layout)
# p.cbln2

p.cbln2.cheungEx = FeaturePlot(cheungEx, 'Cbln2', 
                               order = TRUE,
                               pt.size = 0.25, label = TRUE, label.size = 4) +
  scale_color_gradient(low = 'grey90', high = 'red') +
  theme_void() +
  theme(legend.position = 'none') +
  labs(title = 'Cbln2: Vector-seq')
p.cbln2.cheungEx = umap.axes + p.cbln2.cheungEx + plot_layout(design = layout)
# p.cbln2.cheungEx

p.ntng2.cbln2 = cowplot::plot_grid(p.ntng2, p.ntng2.cheungEx, p.cbln2, p.cbln2.cheungEx, ncol = 2, byrow = TRUE)
ggsave(filename = paste0(results_out, 'corresponding-expression-ntng2-cbln2-umap.tiff'), plot = p.ntng2.cbln2, height = 8, width = 8, dpi = 320, device = 'tiff')
```


### Against Zeisel et al.'s *Molecular Architecture of the Mouse Nervous System*.

Source: https://doi.org/10.1016/j.cell.2018.06.021 Markers: http://mousebrain.org/adolescent/celltypes.html

-   MEGLU1: Syt2 Oscp1 Vamp1
-   MEGLU4: Barhl1 Kcnab1 Sorcs1
-   MEGLU5: Barhl1 Myh8 Rorb Col25a1 Cdh7
-   MEGLU6: Npnt Gpc3 Tmem132c Kcnd3 Tpd52l1
-   MEINH5: Tnnt1 Tnni3 Gata3
-   MEINH6: Fibcd1 Mgarp Lmo1 Vwc2 Npffr1
-   MEINH7: Pax7 Tfap2b Cdhr1 Rnf152 Zfhx4
-   MEINH8: Pax7 Gm27199
-   MEINH10: Otx2 Gabrr2 Cdhr1
-   MEINH11: Sox14 Dmbx1
-   MEINH12: Lhx1os Galnt14

```{r import-zeisel, eval=FALSE}
# tmp <- hdf5r::h5file('ref/l1_midbraindorsal.loom')
# table(tmp[['col_attrs']][['Label']]$read())
# names(tmp[['col_attrs']])
# zeisel.ls <- rhdf5::h5ls(file = 'ref/l1_midbraindorsal.loom')
# zeisel.mat <- rhdf5::h5read(file = 'ref/l1_midbraindorsal.loom', name = '/matrix')
# zeisel.col_attrs <- rhdf5::h5read(file = 'ref/l1_midbraindorsal.loom', name = '/col_attrs')
```

```{r module-scores, eval=FALSE}
zeisel.markers <- list(
  zeisel.MEGLU1 = c('Syt2', 'Oscp1', 'Vamp1'),
  zeisel.MEGLU4 = c('Barhl1', 'Kcnab1', 'Sorcs1'),
  zeisel.MEGLU5 = c('Barhl1', 'Myh8', 'Rorb', 'Col25a1', 'Cdh7'),
  zeisel.MEGLU6 = c('Npnt', 'Gpc3', 'Tmem132c', 'Kcnd3', 'Tpd52l1'),
  zeisel.MEINH5 = c('Tnnt1', 'Tnni3', 'Gata3'),
  zeisel.MEINH6 = c('Fibcd1', 'Mgarp', 'Lmo1', 'Vwc2', 'Npffr1'),
  zeisel.MEINH7 = c('Pax7', 'Tfap2b', 'Cdhr1', 'Rnf152', 'Zfhx4'),
  zeisel.MEINH8 = c('Pax7', 'Gm27199'),
  zeisel.MEINH10 = c('Otx2', 'Gabrr2', 'Cdhr1'),
  zeisel.MEINH11 = c('Sox14', 'Dmbx1'),
  zeisel.MEINH12 = c('Lhx1os', 'Galnt14')
)
neuron <- AddModuleScore(object = neuron, features = zeisel.markers, name = names(zeisel.markers))
colnames(neuron@meta.data)[grepl('zeisel', x = colnames(neuron@meta.data))] <- names(zeisel.markers)

zeisel.plots <- vector(mode = 'list', length = length(zeisel.markers))
names(zeisel.plots) <- names(zeisel.markers)
for (i in seq_along(names(zeisel.markers))) {
  zeisel.plots[[i]] <- FeaturePlot(neuron, names(zeisel.markers)[i], order = TRUE, pt.size = 0.5) +
    scale_color_gradientn(colours = c('grey90','skyblue','royalblue','darkorchid','violetred','red')) +
    labs(title = names(zeisel.markers)[i],
         subtitle = paste(zeisel.markers[[i]], collapse = ', ')) +
    theme_bw() +
    theme(axis.title = element_blank()) +
    guides(color = guide_colorbar(frame.colour = 'black',
                                  frame.linewidth = 1,
                                  ticks.colour = 'black',
                                  ticks.linewidth = 1))
}
p <- Reduce(f = `+`, x = zeisel.plots) + plot_layout(ncol = 4)
ggsave(filename = paste0(results_out, 'zeisel-marker-gene-comparison.tiff'), plot = p, device = 'tiff', height = 9, width = 14, dpi = 320)
```


# FIN

```{r}
sessionInfo()
```

